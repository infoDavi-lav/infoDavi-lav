=== Estratti codice (Import/Export e Backup Officina) ===

[1] Auto-iniettore Import/Export i18n-safe (file esempio/auto-install.php)
// Ripulisce vecchi blocchi e reinserisce HTML/JS localizzati una sola volta
function install_addon(){
    global $html_to_insert,$css_content,$php_ajax_unified,$php_ajax_single,$js_content,$root_dir,$is_web,$AJAX_BLOCK_START,$AJAX_BLOCK_END;
    $content = preg_replace('/<!-- IMPORT\/EXPORT SECTION -->.*?<\/div>\s*<\/div>\s*<\/div>/s', '', $content);
    if($calendario_installato){
        $content = preg_replace('/\/\/ =========================\s*GESTIONE AJAX CALENDARIO.*?\/\* ===== FINE PHP AJAX UNIFICATO ===== \*\//s', '', $content);
        if(preg_match('/\$preventivi_file\s*=\s*[\'\"]images\/info\/preventivi\.json[\'\"];/', $content, $m, PREG_OFFSET_CAPTURE)) {
            $pos = $m[0][1] + strlen($m[0][0]);
            $wrapped = "\n".$AJAX_BLOCK_START."\n".$php_ajax_unified."\n".$AJAX_BLOCK_END."\n";
            $content = substr_replace($content, "\n\n".$wrapped."\n", $pos, 0);
        }
    } else {
        $content = preg_replace('/\/\/ =========================\s*GESTIONE AJAX IMPORT\/EXPORT.*?\/\* ===== FINE PHP AJAX IMPORT\/EXPORT ===== \*\//s', '', $content);
        if(preg_match('/\$preventivi_file\s*=\s*[\'\"]images\/info\/preventivi\.json[\'\"];/', $content, $m, PREG_OFFSET_CAPTURE)) {
            $pos = $m[0][1] + strlen($m[0][0]);
            $wrapped = "\n".$AJAX_BLOCK_START."\n".$php_ajax_single."\n".$AJAX_BLOCK_END."\n";
            $content = substr_replace($content, "\n\n".$wrapped."\n", $pos, 0);
        }
    }
    if (strpos($content, 'import-export-section') === false) {
        $insertPos = strpos($content,'<footer') ?: strlen($content);
        $content = substr_replace($content, $html_to_insert, $insertPos, 0);
    }
    if (strpos($content, 'function exportData(type)') === false) {
        $body_pos = strrpos($content, '</body>') ?: strlen($content);
        $content = substr_replace($content, "\n<script>".$js_content."</script>\n", $body_pos, 0);
    }
    file_put_contents($home_php_path,$content);
}

[2] Builder CSV/JSON per backup multiformato (file esempio/export-zip.php)
// Genera CSV con header dinamici e BOM UTF-8, gestendo liste e dizionari
function build_csv_from_data($data, string $type): string {
    $fp = fopen('php://temp', 'r+'); if ($fp === false) return '';
    if ($type === 'calendar') {
        fputcsv($fp, ['date','text']);
        if (is_array($data)) foreach ($data as $k=>$v) { $text = is_array($v)? json_encode($v, JSON_UNESCAPED_UNICODE): (string)$v; fputcsv($fp, [$k,$text]); }
        rewind($fp); $csv=stream_get_contents($fp); fclose($fp); return "\xEF\xBB\xBF".($csv?:'');
    }
    if (is_array($data) && array_keys($data) === range(0, count($data)-1)) {
        $headers=[]; foreach ($data as $row) if (is_array($row)) foreach ($row as $k=>$_) $headers[$k]=true; $headers=array_keys($headers);
        if ($headers) { fputcsv($fp,$headers); foreach($data as $row){ $line=[]; foreach($headers as $h){ $val=is_array($row)&&array_key_exists($h,$row)?$row[$h]:''; if(is_array($val)||is_object($val)) $val=json_encode($val, JSON_UNESCAPED_UNICODE); $line[]=$val; } fputcsv($fp,$line);} }
        else { fputcsv($fp,['value']); foreach($data as $v){ if(is_array($v)||is_object($v)) $v=json_encode($v, JSON_UNESCAPED_UNICODE); fputcsv($fp,[$v]); } }
        rewind($fp); $csv=stream_get_contents($fp); fclose($fp); return "\xEF\xBB\xBF".($csv?:'');
    }
    fputcsv($fp,['key','value']); if (is_array($data)) foreach($data as $k=>$v){ if(is_array($v)||is_object($v)) $v=json_encode($v, JSON_UNESCAPED_UNICODE); fputcsv($fp,[$k,$v]); }
    rewind($fp); $csv=stream_get_contents($fp); fclose($fp); return "\xEF\xBB\xBF".($csv?:'');
}

[3] Fallback ZIP streaming senza ZipArchive (file esempio/export-zip.php)
// Scrive il file ZIP a mano, utile su hosting condivisi
class SimpleZip {
    private array $entries = [];
    private int $offset = 0;

    public function add(string $name, string $data): void {
        $name = str_replace('\\', '/', $name);
        $time = $this->dosTime(); $date = $this->dosDate(); $crc  = crc32($data);
        $clen = strlen($data); $ulen = $clen;
        $lfh = pack('VvvvvvVVVvv', 0x04034b50, 20, 0, 0, $time, $date, $crc, $clen, $ulen, strlen($name), 0);
        $this->entries[] = ['name'=>$name,'crc'=>$crc,'clen'=>$clen,'ulen'=>$ulen,'time'=>$time,'date'=>$date,'offset'=>$this->offset];
        $this->offset += strlen($lfh) + strlen($name) + $clen;
        echo $lfh . $name . $data;
    }

    public function finish(string $filename): void {
        $cd = '';
        foreach ($this->entries as $e) {
            $cdh = pack('VvvvvvvVVVvvvvvVV', 0x02014b50, 0, 20, 0, 0, $e['time'], $e['date'], $e['crc'], $e['clen'], $e['ulen'], strlen($e['name']), 0, 0, 0, 0, $e['offset']);
            $cd .= $cdh . $e['name'];
        }
        $eocd = pack('VvvvvVVv', 0x06054b50, 0, 0, count($this->entries), count($this->entries), strlen($cd), $this->offset, 0);
        echo $cd . $eocd;
    }

    private function dosTime(): int { $t=getdate(); return (($t['hours']&0x1F)<<11) | (($t['minutes']&0x3F)<<5) | (($t['seconds']/2)&0x1F); }
    private function dosDate(): int { $t=getdate(); return ((($t['year']-1980)&0x7F)<<9) | (($t['mon']&0x0F)<<5) | ($t['mday']&0x1F); }
}

[4] Bootstrap SQLite con migrazione da JSON legacy (file esempio/sqlite_store.php)
// Se il DB e' vuoto importa menu, coperto, tavoli, ordini aperti dai vecchi file
function sqlite_import_legacy_if_needed(PDO $pdo): void {
    $hasCats = (int)$pdo->query('SELECT COUNT(*) FROM categories')->fetchColumn();
    $hasTables = (int)$pdo->query('SELECT COUNT(*) FROM restaurant_tables')->fetchColumn();
    $hasTabs = (int)$pdo->query('SELECT COUNT(*) FROM tabs')->fetchColumn();

    if ($hasCats === 0 && is_readable(DATA_DIR . '/menu.json')) {
        $raw = @file_get_contents(DATA_DIR . '/menu.json');
        $parsed = json_decode((string)$raw, true);
        if (is_array($parsed)) { sqlite_save_menu($parsed); }
    }
    if (sqlite_get_setting('cover_price', null) === null && is_readable(DATA_DIR . '/covers.json')) {
        $raw = @file_get_contents(DATA_DIR . '/covers.json');
        $parsed = json_decode((string)$raw, true);
        if (is_array($parsed) && isset($parsed['coverPrice'])) { sqlite_set_cover_price((float)$parsed['coverPrice']); }
    }
    if ($hasTables === 0 && is_readable(DATA_DIR . '/tables.json')) {
        $raw = @file_get_contents(DATA_DIR . '/tables.json');
        $parsed = json_decode((string)$raw, true);
        if (is_array($parsed)) { sqlite_save_tables($parsed); }
    }
    if ($hasTabs === 0 && is_dir(TABS_DIR)) {
        $files = glob(TABS_DIR . '/table_*.json') ?: [];
        foreach ($files as $file) {
            if (!preg_match('~table_(\d+)\.json$~', $file, $m)) { continue; }
            $tid = (int)$m[1];
            $raw = @file_get_contents($file);
            $parsed = json_decode((string)$raw, true);
            if (is_array($parsed)) { sqlite_save_tab($tid, $parsed); }
        }
    }
    $cartFiles = glob(CARTS_DIR . '/carrello_tavolo_*.json') ?: [];
    foreach ($cartFiles as $file) {
        if (!preg_match('~carrello_tavolo_(\d+)\.json$~', $file, $m)) { continue; }
        $tid = (int)$m[1];
        $raw = @file_get_contents($file);
        $parsed = json_decode((string)$raw, true);
        if (is_array($parsed)) { sqlite_save_cart($tid, $parsed); }
    }
}

[5] Pulizia backup vecchi con log (file esempio/backup_prune.php)
// Cancella backup oltre N giorni e registra il risultato
$keepDays = (int)(getenv('RISTO_BACKUP_KEEP_DAYS') ?: 30);
...
if (is_dir($dir)) {
    foreach (glob($dir . '/db_*.sqlite*') ?: [] as $file) {
        $mtime = (int)@filemtime($file);
        if ($mtime > 0 && $mtime < $now - ($keepDays * 86400)) {
            if (@unlink($file)) { $removed++; }
        } else { $kept++; }
    }
}
if (function_exists('app_log')) {
    app_log('backup_prune', ['keepDays' => $keepDays, 'removed' => $removed, 'kept' => $kept]);
}
